# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pymcell', [dirname(__file__)])
        except ImportError:
            import _pymcell
            return _pymcell
        if fp is not None:
            try:
                _mod = imp.load_module('_pymcell', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pymcell = swig_import_helper()
    del swig_import_helper
else:
    import _pymcell
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


MCELL_SUCCESS = _pymcell.MCELL_SUCCESS
MCELL_FAIL = _pymcell.MCELL_FAIL
class volume(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, volume, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, volume, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> volume"""
        this = _pymcell.new_volume(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_volume
    __del__ = lambda self : None;
volume_swigregister = _pymcell.volume_swigregister
volume_swigregister(volume)

class num_expr_list_head(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_expr_list_head, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_expr_list_head, name)
    __repr__ = _swig_repr
    __swig_setmethods__["value_head"] = _pymcell.num_expr_list_head_value_head_set
    __swig_getmethods__["value_head"] = _pymcell.num_expr_list_head_value_head_get
    if _newclass:value_head = _swig_property(_pymcell.num_expr_list_head_value_head_get, _pymcell.num_expr_list_head_value_head_set)
    __swig_setmethods__["value_tail"] = _pymcell.num_expr_list_head_value_tail_set
    __swig_getmethods__["value_tail"] = _pymcell.num_expr_list_head_value_tail_get
    if _newclass:value_tail = _swig_property(_pymcell.num_expr_list_head_value_tail_get, _pymcell.num_expr_list_head_value_tail_set)
    __swig_setmethods__["value_count"] = _pymcell.num_expr_list_head_value_count_set
    __swig_getmethods__["value_count"] = _pymcell.num_expr_list_head_value_count_get
    if _newclass:value_count = _swig_property(_pymcell.num_expr_list_head_value_count_get, _pymcell.num_expr_list_head_value_count_set)
    __swig_setmethods__["shared"] = _pymcell.num_expr_list_head_shared_set
    __swig_getmethods__["shared"] = _pymcell.num_expr_list_head_shared_get
    if _newclass:shared = _swig_property(_pymcell.num_expr_list_head_shared_get, _pymcell.num_expr_list_head_shared_set)
    def __init__(self, *args): 
        """__init__(self) -> num_expr_list_head"""
        this = _pymcell.new_num_expr_list_head(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_num_expr_list_head
    __del__ = lambda self : None;
num_expr_list_head_swigregister = _pymcell.num_expr_list_head_swigregister
num_expr_list_head_swigregister(num_expr_list_head)


def mcell_create() -> "MCELL_STATE *" :
  return _pymcell.mcell_create()
mcell_create = _pymcell.mcell_create

def mcell_init_state(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_init_state(*args)
mcell_init_state = _pymcell.mcell_init_state

def mcell_init_simulation(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_init_simulation(*args)
mcell_init_simulation = _pymcell.mcell_init_simulation

def mcell_init_read_checkpoint(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_init_read_checkpoint(*args)
mcell_init_read_checkpoint = _pymcell.mcell_init_read_checkpoint

def mcell_init_output(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_init_output(*args)
mcell_init_output = _pymcell.mcell_init_output

def mcell_set_partition(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_set_partition(*args)
mcell_set_partition = _pymcell.mcell_set_partition

def mcell_set_time_step(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_set_time_step(*args)
mcell_set_time_step = _pymcell.mcell_set_time_step

def mcell_set_iterations(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_set_iterations(*args)
mcell_set_iterations = _pymcell.mcell_set_iterations

def mcell_print_version() -> "void" :
  return _pymcell.mcell_print_version()
mcell_print_version = _pymcell.mcell_print_version

def mcell_print_usage(*args) -> "void" :
  return _pymcell.mcell_print_usage(*args)
mcell_print_usage = _pymcell.mcell_print_usage

def mcell_print_stats() -> "void" :
  return _pymcell.mcell_print_stats()
mcell_print_stats = _pymcell.mcell_print_stats

def mcell_argparse(*args) -> "int" :
  return _pymcell.mcell_argparse(*args)
mcell_argparse = _pymcell.mcell_argparse

def mcell_copysort_numeric_list(*args) -> "struct num_expr_list *" :
  return _pymcell.mcell_copysort_numeric_list(*args)
mcell_copysort_numeric_list = _pymcell.mcell_copysort_numeric_list

def mcell_sort_numeric_list(*args) -> "void" :
  return _pymcell.mcell_sort_numeric_list(*args)
mcell_sort_numeric_list = _pymcell.mcell_sort_numeric_list

def mcell_free_numeric_list(*args) -> "void" :
  return _pymcell.mcell_free_numeric_list(*args)
mcell_free_numeric_list = _pymcell.mcell_free_numeric_list

def mcell_generate_range(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_generate_range(*args)
mcell_generate_range = _pymcell.mcell_generate_range

def mcell_generate_range_singleton(*args) -> "int" :
  return _pymcell.mcell_generate_range_singleton(*args)
mcell_generate_range_singleton = _pymcell.mcell_generate_range_singleton

def mcell_print(*args) -> "void" :
  return _pymcell.mcell_print(*args)
mcell_print = _pymcell.mcell_print
class object_creation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, object_creation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, object_creation, name)
    __repr__ = _swig_repr
    __swig_setmethods__["object_name_list"] = _pymcell.object_creation_object_name_list_set
    __swig_getmethods__["object_name_list"] = _pymcell.object_creation_object_name_list_get
    if _newclass:object_name_list = _swig_property(_pymcell.object_creation_object_name_list_get, _pymcell.object_creation_object_name_list_set)
    __swig_setmethods__["object_name_list_end"] = _pymcell.object_creation_object_name_list_end_set
    __swig_getmethods__["object_name_list_end"] = _pymcell.object_creation_object_name_list_end_get
    if _newclass:object_name_list_end = _swig_property(_pymcell.object_creation_object_name_list_end_get, _pymcell.object_creation_object_name_list_end_set)
    __swig_setmethods__["current_object"] = _pymcell.object_creation_current_object_set
    __swig_getmethods__["current_object"] = _pymcell.object_creation_current_object_get
    if _newclass:current_object = _swig_property(_pymcell.object_creation_current_object_get, _pymcell.object_creation_current_object_set)
    def __init__(self, *args): 
        """__init__(self) -> object_creation"""
        this = _pymcell.new_object_creation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_object_creation
    __del__ = lambda self : None;
object_creation_swigregister = _pymcell.object_creation_swigregister
object_creation_swigregister(object_creation)

class poly_object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, poly_object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, poly_object, name)
    __repr__ = _swig_repr
    __swig_setmethods__["obj_name"] = _pymcell.poly_object_obj_name_set
    __swig_getmethods__["obj_name"] = _pymcell.poly_object_obj_name_get
    if _newclass:obj_name = _swig_property(_pymcell.poly_object_obj_name_get, _pymcell.poly_object_obj_name_set)
    __swig_setmethods__["vertices"] = _pymcell.poly_object_vertices_set
    __swig_getmethods__["vertices"] = _pymcell.poly_object_vertices_get
    if _newclass:vertices = _swig_property(_pymcell.poly_object_vertices_get, _pymcell.poly_object_vertices_set)
    __swig_setmethods__["num_vert"] = _pymcell.poly_object_num_vert_set
    __swig_getmethods__["num_vert"] = _pymcell.poly_object_num_vert_get
    if _newclass:num_vert = _swig_property(_pymcell.poly_object_num_vert_get, _pymcell.poly_object_num_vert_set)
    __swig_setmethods__["connections"] = _pymcell.poly_object_connections_set
    __swig_getmethods__["connections"] = _pymcell.poly_object_connections_get
    if _newclass:connections = _swig_property(_pymcell.poly_object_connections_get, _pymcell.poly_object_connections_set)
    __swig_setmethods__["num_conn"] = _pymcell.poly_object_num_conn_set
    __swig_getmethods__["num_conn"] = _pymcell.poly_object_num_conn_get
    if _newclass:num_conn = _swig_property(_pymcell.poly_object_num_conn_get, _pymcell.poly_object_num_conn_set)
    def __init__(self, *args): 
        """__init__(self) -> poly_object"""
        this = _pymcell.new_poly_object(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_poly_object
    __del__ = lambda self : None;
poly_object_swigregister = _pymcell.poly_object_swigregister
poly_object_swigregister(poly_object)


def mcell_create_instance_object(*args) -> "struct object **" :
  return _pymcell.mcell_create_instance_object(*args)
mcell_create_instance_object = _pymcell.mcell_create_instance_object

def mcell_create_poly_object(*args) -> "struct object **" :
  return _pymcell.mcell_create_poly_object(*args)
mcell_create_poly_object = _pymcell.mcell_create_poly_object

def new_polygon_list(*args) -> "struct polygon_object *" :
  return _pymcell.new_polygon_list(*args)
new_polygon_list = _pymcell.new_polygon_list

def make_new_object(*args) -> "struct object *" :
  return _pymcell.make_new_object(*args)
make_new_object = _pymcell.make_new_object

def push_object_name(*args) -> "char *" :
  return _pymcell.push_object_name(*args)
push_object_name = _pymcell.push_object_name

def pop_object_name(*args) -> "void" :
  return _pymcell.pop_object_name(*args)
pop_object_name = _pymcell.pop_object_name

def mcell_add_to_vertex_list(*args) -> "struct vertex_list *" :
  return _pymcell.mcell_add_to_vertex_list(*args)
mcell_add_to_vertex_list = _pymcell.mcell_add_to_vertex_list

def free_vertex_list(*args) -> "void" :
  return _pymcell.free_vertex_list(*args)
free_vertex_list = _pymcell.free_vertex_list

def mcell_add_to_connection_list(*args) -> "struct element_connection_list *" :
  return _pymcell.mcell_add_to_connection_list(*args)
mcell_add_to_connection_list = _pymcell.mcell_add_to_connection_list

def free_connection_list(*args) -> "void" :
  return _pymcell.free_connection_list(*args)
free_connection_list = _pymcell.free_connection_list

def mcell_set_region_elements(*args) -> "int" :
  return _pymcell.mcell_set_region_elements(*args)
mcell_set_region_elements = _pymcell.mcell_set_region_elements

def mcell_add_to_region_list(*args) -> "struct element_list *" :
  return _pymcell.mcell_add_to_region_list(*args)
mcell_add_to_region_list = _pymcell.mcell_add_to_region_list

def add_child_objects(*args) -> "void" :
  return _pymcell.add_child_objects(*args)
add_child_objects = _pymcell.add_child_objects

def mcell_create_region(*args) -> "struct region *" :
  return _pymcell.mcell_create_region(*args)
mcell_create_region = _pymcell.mcell_create_region

def make_new_region(*args) -> "struct region *" :
  return _pymcell.make_new_region(*args)
make_new_region = _pymcell.make_new_region

def remove_gaps_from_regions(*args) -> "void" :
  return _pymcell.remove_gaps_from_regions(*args)
remove_gaps_from_regions = _pymcell.remove_gaps_from_regions

def check_degenerate_polygon_list(*args) -> "int" :
  return _pymcell.check_degenerate_polygon_list(*args)
check_degenerate_polygon_list = _pymcell.check_degenerate_polygon_list

def common_ancestor(*args) -> "struct object *" :
  return _pymcell.common_ancestor(*args)
common_ancestor = _pymcell.common_ancestor

def allocate_polygon_object(*args) -> "struct polygon_object *" :
  return _pymcell.allocate_polygon_object(*args)
allocate_polygon_object = _pymcell.allocate_polygon_object

def new_element_list(*args) -> "struct element_list *" :
  return _pymcell.new_element_list(*args)
new_element_list = _pymcell.new_element_list

def normalize_elements(*args) -> "int" :
  return _pymcell.normalize_elements(*args)
normalize_elements = _pymcell.normalize_elements

def count_cuboid_elements(*args) -> "int" :
  return _pymcell.count_cuboid_elements(*args)
count_cuboid_elements = _pymcell.count_cuboid_elements

def cuboid_patch_to_bits(*args) -> "int" :
  return _pymcell.cuboid_patch_to_bits(*args)
cuboid_patch_to_bits = _pymcell.cuboid_patch_to_bits

def check_patch(*args) -> "int" :
  return _pymcell.check_patch(*args)
check_patch = _pymcell.check_patch

def mcell_get_obj_sym(*args) -> "struct sym_entry *" :
  return _pymcell.mcell_get_obj_sym(*args)
mcell_get_obj_sym = _pymcell.mcell_get_obj_sym

def mcell_get_reg_sym(*args) -> "struct sym_entry *" :
  return _pymcell.mcell_get_reg_sym(*args)
mcell_get_reg_sym = _pymcell.mcell_get_reg_sym
class output_column_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_column_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_column_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["column_head"] = _pymcell.output_column_list_column_head_set
    __swig_getmethods__["column_head"] = _pymcell.output_column_list_column_head_get
    if _newclass:column_head = _swig_property(_pymcell.output_column_list_column_head_get, _pymcell.output_column_list_column_head_set)
    __swig_setmethods__["column_tail"] = _pymcell.output_column_list_column_tail_set
    __swig_getmethods__["column_tail"] = _pymcell.output_column_list_column_tail_get
    if _newclass:column_tail = _swig_property(_pymcell.output_column_list_column_tail_get, _pymcell.output_column_list_column_tail_set)
    def __init__(self, *args): 
        """__init__(self) -> output_column_list"""
        this = _pymcell.new_output_column_list(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_output_column_list
    __del__ = lambda self : None;
output_column_list_swigregister = _pymcell.output_column_list_swigregister
output_column_list_swigregister(output_column_list)

class output_set_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_set_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_set_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["set_head"] = _pymcell.output_set_list_set_head_set
    __swig_getmethods__["set_head"] = _pymcell.output_set_list_set_head_get
    if _newclass:set_head = _swig_property(_pymcell.output_set_list_set_head_get, _pymcell.output_set_list_set_head_set)
    __swig_setmethods__["set_tail"] = _pymcell.output_set_list_set_tail_set
    __swig_getmethods__["set_tail"] = _pymcell.output_set_list_set_tail_get
    if _newclass:set_tail = _swig_property(_pymcell.output_set_list_set_tail_get, _pymcell.output_set_list_set_tail_set)
    def __init__(self, *args): 
        """__init__(self) -> output_set_list"""
        this = _pymcell.new_output_set_list(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_output_set_list
    __del__ = lambda self : None;
output_set_list_swigregister = _pymcell.output_set_list_swigregister
output_set_list_swigregister(output_set_list)

class output_times_inlist(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_times_inlist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_times_inlist, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _pymcell.output_times_inlist_type_set
    __swig_getmethods__["type"] = _pymcell.output_times_inlist_type_get
    if _newclass:type = _swig_property(_pymcell.output_times_inlist_type_get, _pymcell.output_times_inlist_type_set)
    __swig_setmethods__["step"] = _pymcell.output_times_inlist_step_set
    __swig_getmethods__["step"] = _pymcell.output_times_inlist_step_get
    if _newclass:step = _swig_property(_pymcell.output_times_inlist_step_get, _pymcell.output_times_inlist_step_set)
    __swig_setmethods__["values"] = _pymcell.output_times_inlist_values_set
    __swig_getmethods__["values"] = _pymcell.output_times_inlist_values_get
    if _newclass:values = _swig_property(_pymcell.output_times_inlist_values_get, _pymcell.output_times_inlist_values_set)
    def __init__(self, *args): 
        """__init__(self) -> output_times_inlist"""
        this = _pymcell.new_output_times_inlist(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_output_times_inlist
    __del__ = lambda self : None;
output_times_inlist_swigregister = _pymcell.output_times_inlist_swigregister
output_times_inlist_swigregister(output_times_inlist)


def mcell_get_count(*args) -> "int" :
  return _pymcell.mcell_get_count(*args)
mcell_get_count = _pymcell.mcell_get_count

def mcell_new_output_request(*args) -> "struct output_request *" :
  return _pymcell.mcell_new_output_request(*args)
mcell_new_output_request = _pymcell.mcell_new_output_request

def mcell_create_new_output_set(*args) -> "struct output_set *" :
  return _pymcell.mcell_create_new_output_set(*args)
mcell_create_new_output_set = _pymcell.mcell_create_new_output_set

def mcell_prepare_single_count_expr(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_prepare_single_count_expr(*args)
mcell_prepare_single_count_expr = _pymcell.mcell_prepare_single_count_expr

def mcell_add_reaction_output_block(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_add_reaction_output_block(*args)
mcell_add_reaction_output_block = _pymcell.mcell_add_reaction_output_block

def mcell_create_count(*args) -> "struct output_column_list *" :
  return _pymcell.mcell_create_count(*args)
mcell_create_count = _pymcell.mcell_create_count

def mcell_get_counter_value(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_get_counter_value(*args)
mcell_get_counter_value = _pymcell.mcell_get_counter_value
REGULAR_ARROW = _pymcell.REGULAR_ARROW
ARROW_BIDIRECTIONAL = _pymcell.ARROW_BIDIRECTIONAL
ARROW_CATALYTIC = _pymcell.ARROW_CATALYTIC
RATE_UNSET = _pymcell.RATE_UNSET
RATE_CONSTANT = _pymcell.RATE_CONSTANT
RATE_FILE = _pymcell.RATE_FILE
RFLCT = _pymcell.RFLCT
TRANSP = _pymcell.TRANSP
SINK = _pymcell.SINK
class reaction_def(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_def, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_def, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sym"] = _pymcell.reaction_def_sym_set
    __swig_getmethods__["sym"] = _pymcell.reaction_def_sym_get
    if _newclass:sym = _swig_property(_pymcell.reaction_def_sym_get, _pymcell.reaction_def_sym_set)
    def __init__(self, *args): 
        """__init__(self) -> reaction_def"""
        this = _pymcell.new_reaction_def(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_def
    __del__ = lambda self : None;
reaction_def_swigregister = _pymcell.reaction_def_swigregister
reaction_def_swigregister(reaction_def)

class release_single_molecule_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, release_single_molecule_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, release_single_molecule_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rsm_head"] = _pymcell.release_single_molecule_list_rsm_head_set
    __swig_getmethods__["rsm_head"] = _pymcell.release_single_molecule_list_rsm_head_get
    if _newclass:rsm_head = _swig_property(_pymcell.release_single_molecule_list_rsm_head_get, _pymcell.release_single_molecule_list_rsm_head_set)
    __swig_setmethods__["rsm_tail"] = _pymcell.release_single_molecule_list_rsm_tail_set
    __swig_getmethods__["rsm_tail"] = _pymcell.release_single_molecule_list_rsm_tail_get
    if _newclass:rsm_tail = _swig_property(_pymcell.release_single_molecule_list_rsm_tail_get, _pymcell.release_single_molecule_list_rsm_tail_set)
    __swig_setmethods__["rsm_count"] = _pymcell.release_single_molecule_list_rsm_count_set
    __swig_getmethods__["rsm_count"] = _pymcell.release_single_molecule_list_rsm_count_get
    if _newclass:rsm_count = _swig_property(_pymcell.release_single_molecule_list_rsm_count_get, _pymcell.release_single_molecule_list_rsm_count_set)
    def __init__(self, *args): 
        """__init__(self) -> release_single_molecule_list"""
        this = _pymcell.new_release_single_molecule_list(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_release_single_molecule_list
    __del__ = lambda self : None;
release_single_molecule_list_swigregister = _pymcell.release_single_molecule_list_swigregister
release_single_molecule_list_swigregister(release_single_molecule_list)

class reaction_arrow(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_arrow, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_arrow, name)
    __repr__ = _swig_repr
    __swig_setmethods__["flags"] = _pymcell.reaction_arrow_flags_set
    __swig_getmethods__["flags"] = _pymcell.reaction_arrow_flags_get
    if _newclass:flags = _swig_property(_pymcell.reaction_arrow_flags_get, _pymcell.reaction_arrow_flags_set)
    __swig_setmethods__["catalyst"] = _pymcell.reaction_arrow_catalyst_set
    __swig_getmethods__["catalyst"] = _pymcell.reaction_arrow_catalyst_get
    if _newclass:catalyst = _swig_property(_pymcell.reaction_arrow_catalyst_get, _pymcell.reaction_arrow_catalyst_set)
    def __init__(self, *args): 
        """__init__(self) -> reaction_arrow"""
        this = _pymcell.new_reaction_arrow(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_arrow
    __del__ = lambda self : None;
reaction_arrow_swigregister = _pymcell.reaction_arrow_swigregister
reaction_arrow_swigregister(reaction_arrow)

class reaction_rate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rate, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rate_type"] = _pymcell.reaction_rate_rate_type_set
    __swig_getmethods__["rate_type"] = _pymcell.reaction_rate_rate_type_get
    if _newclass:rate_type = _swig_property(_pymcell.reaction_rate_rate_type_get, _pymcell.reaction_rate_rate_type_set)
    __swig_getmethods__["v"] = _pymcell.reaction_rate_v_get
    if _newclass:v = _swig_property(_pymcell.reaction_rate_v_get)
    def __init__(self, *args): 
        """__init__(self) -> reaction_rate"""
        this = _pymcell.new_reaction_rate(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rate
    __del__ = lambda self : None;
reaction_rate_swigregister = _pymcell.reaction_rate_swigregister
reaction_rate_swigregister(reaction_rate)

class reaction_rate_v(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rate_v, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rate_v, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rate_constant"] = _pymcell.reaction_rate_v_rate_constant_set
    __swig_getmethods__["rate_constant"] = _pymcell.reaction_rate_v_rate_constant_get
    if _newclass:rate_constant = _swig_property(_pymcell.reaction_rate_v_rate_constant_get, _pymcell.reaction_rate_v_rate_constant_set)
    __swig_setmethods__["rate_file"] = _pymcell.reaction_rate_v_rate_file_set
    __swig_getmethods__["rate_file"] = _pymcell.reaction_rate_v_rate_file_get
    if _newclass:rate_file = _swig_property(_pymcell.reaction_rate_v_rate_file_get, _pymcell.reaction_rate_v_rate_file_set)
    def __init__(self, *args): 
        """__init__(self) -> reaction_rate_v"""
        this = _pymcell.new_reaction_rate_v(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rate_v
    __del__ = lambda self : None;
reaction_rate_v_swigregister = _pymcell.reaction_rate_v_swigregister
reaction_rate_v_swigregister(reaction_rate_v)

class reaction_rates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rates, name)
    __repr__ = _swig_repr
    __swig_setmethods__["forward_rate"] = _pymcell.reaction_rates_forward_rate_set
    __swig_getmethods__["forward_rate"] = _pymcell.reaction_rates_forward_rate_get
    if _newclass:forward_rate = _swig_property(_pymcell.reaction_rates_forward_rate_get, _pymcell.reaction_rates_forward_rate_set)
    __swig_setmethods__["backward_rate"] = _pymcell.reaction_rates_backward_rate_set
    __swig_getmethods__["backward_rate"] = _pymcell.reaction_rates_backward_rate_get
    if _newclass:backward_rate = _swig_property(_pymcell.reaction_rates_backward_rate_get, _pymcell.reaction_rates_backward_rate_set)
    def __init__(self, *args): 
        """__init__(self) -> reaction_rates"""
        this = _pymcell.new_reaction_rates(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rates
    __del__ = lambda self : None;
reaction_rates_swigregister = _pymcell.reaction_rates_swigregister
reaction_rates_swigregister(reaction_rates)


def mcell_modify_rate_constant(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_modify_rate_constant(*args)
mcell_modify_rate_constant = _pymcell.mcell_modify_rate_constant

def mcell_add_reaction_simplified(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_add_reaction_simplified(*args)
mcell_add_reaction_simplified = _pymcell.mcell_add_reaction_simplified

def mcell_add_reaction(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_add_reaction(*args)
mcell_add_reaction = _pymcell.mcell_add_reaction

def mcell_add_surface_reaction(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_add_surface_reaction(*args)
mcell_add_surface_reaction = _pymcell.mcell_add_surface_reaction

def mcell_add_concentration_clamp(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_add_concentration_clamp(*args)
mcell_add_concentration_clamp = _pymcell.mcell_add_concentration_clamp

def init_reactions(*args) -> "MCELL_STATUS" :
  return _pymcell.init_reactions(*args)
init_reactions = _pymcell.init_reactions

def mcell_change_reaction_rate(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_change_reaction_rate(*args)
mcell_change_reaction_rate = _pymcell.mcell_change_reaction_rate

def mcell_create_reaction_rates(*args) -> "struct reaction_rates" :
  return _pymcell.mcell_create_reaction_rates(*args)
mcell_create_reaction_rates = _pymcell.mcell_create_reaction_rates

def mcell_new_rxn_pathname(*args) -> "struct sym_entry *" :
  return _pymcell.mcell_new_rxn_pathname(*args)
mcell_new_rxn_pathname = _pymcell.mcell_new_rxn_pathname

def mcell_create_geometrical_release_site(*args) -> "struct object **" :
  return _pymcell.mcell_create_geometrical_release_site(*args)
mcell_create_geometrical_release_site = _pymcell.mcell_create_geometrical_release_site

def mcell_start_release_site(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_start_release_site(*args)
mcell_start_release_site = _pymcell.mcell_start_release_site

def mcell_finish_release_site(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_finish_release_site(*args)
mcell_finish_release_site = _pymcell.mcell_finish_release_site

def set_release_site_concentration(*args) -> "int" :
  return _pymcell.set_release_site_concentration(*args)
set_release_site_concentration = _pymcell.set_release_site_concentration

def mcell_create_region_release(*args) -> "struct object **" :
  return _pymcell.mcell_create_region_release(*args)
mcell_create_region_release = _pymcell.mcell_create_region_release

def mcell_set_release_site_geometry_region(*args) -> "int" :
  return _pymcell.mcell_set_release_site_geometry_region(*args)
mcell_set_release_site_geometry_region = _pymcell.mcell_set_release_site_geometry_region

def check_release_regions(*args) -> "int" :
  return _pymcell.check_release_regions(*args)
check_release_regions = _pymcell.check_release_regions

def is_release_site_valid(*args) -> "int" :
  return _pymcell.is_release_site_valid(*args)
is_release_site_valid = _pymcell.is_release_site_valid

def new_release_region_expr_term(*args) -> "struct release_evaluator *" :
  return _pymcell.new_release_region_expr_term(*args)
new_release_region_expr_term = _pymcell.new_release_region_expr_term

def set_release_site_constant_number(*args) -> "void" :
  return _pymcell.set_release_site_constant_number(*args)
set_release_site_constant_number = _pymcell.set_release_site_constant_number

def set_release_site_gaussian_number(*args) -> "void" :
  return _pymcell.set_release_site_gaussian_number(*args)
set_release_site_gaussian_number = _pymcell.set_release_site_gaussian_number

def new_release_region_expr_binary(*args) -> "struct release_evaluator *" :
  return _pymcell.new_release_region_expr_binary(*args)
new_release_region_expr_binary = _pymcell.new_release_region_expr_binary

def set_release_site_location(*args) -> "void" :
  return _pymcell.set_release_site_location(*args)
set_release_site_location = _pymcell.set_release_site_location
class mcell_symbol(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_symbol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_symbol, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.mcell_symbol_next_set
    __swig_getmethods__["next"] = _pymcell.mcell_symbol_next_get
    if _newclass:next = _swig_property(_pymcell.mcell_symbol_next_get, _pymcell.mcell_symbol_next_set)
    __swig_setmethods__["sym_type"] = _pymcell.mcell_symbol_sym_type_set
    __swig_getmethods__["sym_type"] = _pymcell.mcell_symbol_sym_type_get
    if _newclass:sym_type = _swig_property(_pymcell.mcell_symbol_sym_type_get, _pymcell.mcell_symbol_sym_type_set)
    __swig_setmethods__["name"] = _pymcell.mcell_symbol_name_set
    __swig_getmethods__["name"] = _pymcell.mcell_symbol_name_get
    if _newclass:name = _swig_property(_pymcell.mcell_symbol_name_get, _pymcell.mcell_symbol_name_set)
    __swig_setmethods__["value"] = _pymcell.mcell_symbol_value_set
    __swig_getmethods__["value"] = _pymcell.mcell_symbol_value_get
    if _newclass:value = _swig_property(_pymcell.mcell_symbol_value_get, _pymcell.mcell_symbol_value_set)
    def __init__(self, *args): 
        """__init__(self) -> mcell_symbol"""
        this = _pymcell.new_mcell_symbol(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_symbol
    __del__ = lambda self : None;
mcell_symbol_swigregister = _pymcell.mcell_symbol_swigregister
mcell_symbol_swigregister(mcell_symbol)

class mcell_species_spec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species_spec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species_spec, name)
    __repr__ = _swig_repr
    __swig_setmethods__["name"] = _pymcell.mcell_species_spec_name_set
    __swig_getmethods__["name"] = _pymcell.mcell_species_spec_name_get
    if _newclass:name = _swig_property(_pymcell.mcell_species_spec_name_get, _pymcell.mcell_species_spec_name_set)
    __swig_setmethods__["D"] = _pymcell.mcell_species_spec_D_set
    __swig_getmethods__["D"] = _pymcell.mcell_species_spec_D_get
    if _newclass:D = _swig_property(_pymcell.mcell_species_spec_D_get, _pymcell.mcell_species_spec_D_set)
    __swig_setmethods__["is_2d"] = _pymcell.mcell_species_spec_is_2d_set
    __swig_getmethods__["is_2d"] = _pymcell.mcell_species_spec_is_2d_get
    if _newclass:is_2d = _swig_property(_pymcell.mcell_species_spec_is_2d_get, _pymcell.mcell_species_spec_is_2d_set)
    __swig_setmethods__["custom_time_step"] = _pymcell.mcell_species_spec_custom_time_step_set
    __swig_getmethods__["custom_time_step"] = _pymcell.mcell_species_spec_custom_time_step_get
    if _newclass:custom_time_step = _swig_property(_pymcell.mcell_species_spec_custom_time_step_get, _pymcell.mcell_species_spec_custom_time_step_set)
    __swig_setmethods__["target_only"] = _pymcell.mcell_species_spec_target_only_set
    __swig_getmethods__["target_only"] = _pymcell.mcell_species_spec_target_only_get
    if _newclass:target_only = _swig_property(_pymcell.mcell_species_spec_target_only_get, _pymcell.mcell_species_spec_target_only_set)
    __swig_setmethods__["max_step_length"] = _pymcell.mcell_species_spec_max_step_length_set
    __swig_getmethods__["max_step_length"] = _pymcell.mcell_species_spec_max_step_length_get
    if _newclass:max_step_length = _swig_property(_pymcell.mcell_species_spec_max_step_length_get, _pymcell.mcell_species_spec_max_step_length_set)
    __swig_setmethods__["space_step"] = _pymcell.mcell_species_spec_space_step_set
    __swig_getmethods__["space_step"] = _pymcell.mcell_species_spec_space_step_get
    if _newclass:space_step = _swig_property(_pymcell.mcell_species_spec_space_step_get, _pymcell.mcell_species_spec_space_step_set)
    def __init__(self, *args): 
        """__init__(self) -> mcell_species_spec"""
        this = _pymcell.new_mcell_species_spec(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species_spec
    __del__ = lambda self : None;
mcell_species_spec_swigregister = _pymcell.mcell_species_spec_swigregister
mcell_species_spec_swigregister(mcell_species_spec)

class mcell_species(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.mcell_species_next_set
    __swig_getmethods__["next"] = _pymcell.mcell_species_next_get
    if _newclass:next = _swig_property(_pymcell.mcell_species_next_get, _pymcell.mcell_species_next_set)
    __swig_setmethods__["mol_type"] = _pymcell.mcell_species_mol_type_set
    __swig_getmethods__["mol_type"] = _pymcell.mcell_species_mol_type_get
    if _newclass:mol_type = _swig_property(_pymcell.mcell_species_mol_type_get, _pymcell.mcell_species_mol_type_set)
    __swig_setmethods__["orient_set"] = _pymcell.mcell_species_orient_set_set
    __swig_getmethods__["orient_set"] = _pymcell.mcell_species_orient_set_get
    if _newclass:orient_set = _swig_property(_pymcell.mcell_species_orient_set_get, _pymcell.mcell_species_orient_set_set)
    __swig_setmethods__["orient"] = _pymcell.mcell_species_orient_set
    __swig_getmethods__["orient"] = _pymcell.mcell_species_orient_get
    if _newclass:orient = _swig_property(_pymcell.mcell_species_orient_get, _pymcell.mcell_species_orient_set)
    def __init__(self, *args): 
        """__init__(self) -> mcell_species"""
        this = _pymcell.new_mcell_species(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species
    __del__ = lambda self : None;
mcell_species_swigregister = _pymcell.mcell_species_swigregister
mcell_species_swigregister(mcell_species)

class mcell_species_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mol_type_head"] = _pymcell.mcell_species_list_mol_type_head_set
    __swig_getmethods__["mol_type_head"] = _pymcell.mcell_species_list_mol_type_head_get
    if _newclass:mol_type_head = _swig_property(_pymcell.mcell_species_list_mol_type_head_get, _pymcell.mcell_species_list_mol_type_head_set)
    __swig_setmethods__["mol_type_tail"] = _pymcell.mcell_species_list_mol_type_tail_set
    __swig_getmethods__["mol_type_tail"] = _pymcell.mcell_species_list_mol_type_tail_get
    if _newclass:mol_type_tail = _swig_property(_pymcell.mcell_species_list_mol_type_tail_get, _pymcell.mcell_species_list_mol_type_tail_set)
    def __init__(self, *args): 
        """__init__(self) -> mcell_species_list"""
        this = _pymcell.new_mcell_species_list(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species_list
    __del__ = lambda self : None;
mcell_species_list_swigregister = _pymcell.mcell_species_list_swigregister
mcell_species_list_swigregister(mcell_species_list)


def mcell_create_species(*args) -> "struct sym_entry **" :
  return _pymcell.mcell_create_species(*args)
mcell_create_species = _pymcell.mcell_create_species

def mcell_add_to_species_list(*args) -> "struct mcell_species *" :
  return _pymcell.mcell_add_to_species_list(*args)
mcell_add_to_species_list = _pymcell.mcell_add_to_species_list

def mcell_delete_species_list(*args) -> "void" :
  return _pymcell.mcell_delete_species_list(*args)
mcell_delete_species_list = _pymcell.mcell_delete_species_list

def new_mol_species(*args) -> "int" :
  return _pymcell.new_mol_species(*args)
new_mol_species = _pymcell.new_mol_species

def mcell_create_viz_output(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_create_viz_output(*args)
mcell_create_viz_output = _pymcell.mcell_create_viz_output

def mcell_new_viz_output_block(*args) -> "void" :
  return _pymcell.mcell_new_viz_output_block(*args)
mcell_new_viz_output_block = _pymcell.mcell_new_viz_output_block

def mcell_create_viz_frame(*args) -> "struct frame_data_list *" :
  return _pymcell.mcell_create_viz_frame(*args)
mcell_create_viz_frame = _pymcell.mcell_create_viz_frame

def mcell_set_molecule_viz_state(*args) -> "int" :
  return _pymcell.mcell_set_molecule_viz_state(*args)
mcell_set_molecule_viz_state = _pymcell.mcell_set_molecule_viz_state

def mcell_add_surf_class_properties(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_add_surf_class_properties(*args)
mcell_add_surf_class_properties = _pymcell.mcell_add_surf_class_properties

def mcell_create_surf_class(*args) -> "struct sym_entry **" :
  return _pymcell.mcell_create_surf_class(*args)
mcell_create_surf_class = _pymcell.mcell_create_surf_class

def mcell_add_mol_release_to_surf_class(*args) -> "struct sm_dat *" :
  return _pymcell.mcell_add_mol_release_to_surf_class(*args)
mcell_add_mol_release_to_surf_class = _pymcell.mcell_add_mol_release_to_surf_class

def mcell_assign_surf_class_to_region(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_assign_surf_class_to_region(*args)
mcell_assign_surf_class_to_region = _pymcell.mcell_assign_surf_class_to_region

def mcell_run_simulation(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_run_simulation(*args)
mcell_run_simulation = _pymcell.mcell_run_simulation

def mcell_run_iteration(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_run_iteration(*args)
mcell_run_iteration = _pymcell.mcell_run_iteration

def mcell_flush_data(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_flush_data(*args)
mcell_flush_data = _pymcell.mcell_flush_data

def mcell_print_final_warnings(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_print_final_warnings(*args)
mcell_print_final_warnings = _pymcell.mcell_print_final_warnings

def mcell_print_final_statistics(*args) -> "MCELL_STATUS" :
  return _pymcell.mcell_print_final_statistics(*args)
mcell_print_final_statistics = _pymcell.mcell_print_final_statistics
ORIENT_NOT_SET = _pymcell.ORIENT_NOT_SET
class object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, object, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.object_next_set
    __swig_getmethods__["next"] = _pymcell.object_next_get
    if _newclass:next = _swig_property(_pymcell.object_next_get, _pymcell.object_next_set)
    __swig_setmethods__["parent"] = _pymcell.object_parent_set
    __swig_getmethods__["parent"] = _pymcell.object_parent_get
    if _newclass:parent = _swig_property(_pymcell.object_parent_get, _pymcell.object_parent_set)
    __swig_setmethods__["first_child"] = _pymcell.object_first_child_set
    __swig_getmethods__["first_child"] = _pymcell.object_first_child_get
    if _newclass:first_child = _swig_property(_pymcell.object_first_child_get, _pymcell.object_first_child_set)
    __swig_setmethods__["last_child"] = _pymcell.object_last_child_set
    __swig_getmethods__["last_child"] = _pymcell.object_last_child_get
    if _newclass:last_child = _swig_property(_pymcell.object_last_child_get, _pymcell.object_last_child_set)
    __swig_setmethods__["sym"] = _pymcell.object_sym_set
    __swig_getmethods__["sym"] = _pymcell.object_sym_get
    if _newclass:sym = _swig_property(_pymcell.object_sym_get, _pymcell.object_sym_set)
    __swig_setmethods__["last_name"] = _pymcell.object_last_name_set
    __swig_getmethods__["last_name"] = _pymcell.object_last_name_get
    if _newclass:last_name = _swig_property(_pymcell.object_last_name_get, _pymcell.object_last_name_set)
    __swig_setmethods__["object_type"] = _pymcell.object_object_type_set
    __swig_getmethods__["object_type"] = _pymcell.object_object_type_get
    if _newclass:object_type = _swig_property(_pymcell.object_object_type_get, _pymcell.object_object_type_set)
    __swig_setmethods__["contents"] = _pymcell.object_contents_set
    __swig_getmethods__["contents"] = _pymcell.object_contents_get
    if _newclass:contents = _swig_property(_pymcell.object_contents_get, _pymcell.object_contents_set)
    __swig_setmethods__["num_regions"] = _pymcell.object_num_regions_set
    __swig_getmethods__["num_regions"] = _pymcell.object_num_regions_get
    if _newclass:num_regions = _swig_property(_pymcell.object_num_regions_get, _pymcell.object_num_regions_set)
    __swig_setmethods__["regions"] = _pymcell.object_regions_set
    __swig_getmethods__["regions"] = _pymcell.object_regions_get
    if _newclass:regions = _swig_property(_pymcell.object_regions_get, _pymcell.object_regions_set)
    __swig_setmethods__["n_walls"] = _pymcell.object_n_walls_set
    __swig_getmethods__["n_walls"] = _pymcell.object_n_walls_get
    if _newclass:n_walls = _swig_property(_pymcell.object_n_walls_get, _pymcell.object_n_walls_set)
    __swig_setmethods__["n_walls_actual"] = _pymcell.object_n_walls_actual_set
    __swig_getmethods__["n_walls_actual"] = _pymcell.object_n_walls_actual_get
    if _newclass:n_walls_actual = _swig_property(_pymcell.object_n_walls_actual_get, _pymcell.object_n_walls_actual_set)
    __swig_setmethods__["walls"] = _pymcell.object_walls_set
    __swig_getmethods__["walls"] = _pymcell.object_walls_get
    if _newclass:walls = _swig_property(_pymcell.object_walls_get, _pymcell.object_walls_set)
    __swig_setmethods__["wall_p"] = _pymcell.object_wall_p_set
    __swig_getmethods__["wall_p"] = _pymcell.object_wall_p_get
    if _newclass:wall_p = _swig_property(_pymcell.object_wall_p_get, _pymcell.object_wall_p_set)
    __swig_setmethods__["n_verts"] = _pymcell.object_n_verts_set
    __swig_getmethods__["n_verts"] = _pymcell.object_n_verts_get
    if _newclass:n_verts = _swig_property(_pymcell.object_n_verts_get, _pymcell.object_n_verts_set)
    __swig_setmethods__["vertices"] = _pymcell.object_vertices_set
    __swig_getmethods__["vertices"] = _pymcell.object_vertices_get
    if _newclass:vertices = _swig_property(_pymcell.object_vertices_get, _pymcell.object_vertices_set)
    __swig_setmethods__["total_area"] = _pymcell.object_total_area_set
    __swig_getmethods__["total_area"] = _pymcell.object_total_area_get
    if _newclass:total_area = _swig_property(_pymcell.object_total_area_get, _pymcell.object_total_area_set)
    __swig_setmethods__["n_tiles"] = _pymcell.object_n_tiles_set
    __swig_getmethods__["n_tiles"] = _pymcell.object_n_tiles_get
    if _newclass:n_tiles = _swig_property(_pymcell.object_n_tiles_get, _pymcell.object_n_tiles_set)
    __swig_setmethods__["n_occupied_tiles"] = _pymcell.object_n_occupied_tiles_set
    __swig_getmethods__["n_occupied_tiles"] = _pymcell.object_n_occupied_tiles_get
    if _newclass:n_occupied_tiles = _swig_property(_pymcell.object_n_occupied_tiles_get, _pymcell.object_n_occupied_tiles_set)
    __swig_setmethods__["t_matrix"] = _pymcell.object_t_matrix_set
    __swig_getmethods__["t_matrix"] = _pymcell.object_t_matrix_get
    if _newclass:t_matrix = _swig_property(_pymcell.object_t_matrix_get, _pymcell.object_t_matrix_set)
    __swig_setmethods__["periodic_x"] = _pymcell.object_periodic_x_set
    __swig_getmethods__["periodic_x"] = _pymcell.object_periodic_x_get
    if _newclass:periodic_x = _swig_property(_pymcell.object_periodic_x_get, _pymcell.object_periodic_x_set)
    __swig_setmethods__["periodic_y"] = _pymcell.object_periodic_y_set
    __swig_getmethods__["periodic_y"] = _pymcell.object_periodic_y_get
    if _newclass:periodic_y = _swig_property(_pymcell.object_periodic_y_get, _pymcell.object_periodic_y_set)
    __swig_setmethods__["periodic_z"] = _pymcell.object_periodic_z_set
    __swig_getmethods__["periodic_z"] = _pymcell.object_periodic_z_get
    if _newclass:periodic_z = _swig_property(_pymcell.object_periodic_z_get, _pymcell.object_periodic_z_set)
    def __init__(self, *args): 
        """__init__(self) -> object"""
        this = _pymcell.new_object(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_object
    __del__ = lambda self : None;
object_swigregister = _pymcell.object_swigregister
object_swigregister(object)

SHAPE_UNDEFINED = _pymcell.SHAPE_UNDEFINED
SHAPE_SPHERICAL = _pymcell.SHAPE_SPHERICAL
SHAPE_CUBIC = _pymcell.SHAPE_CUBIC
SHAPE_ELLIPTIC = _pymcell.SHAPE_ELLIPTIC
SHAPE_RECTANGULAR = _pymcell.SHAPE_RECTANGULAR
SHAPE_SPHERICAL_SHELL = _pymcell.SHAPE_SPHERICAL_SHELL
SHAPE_REGION = _pymcell.SHAPE_REGION
SHAPE_LIST = _pymcell.SHAPE_LIST
FILE_UNDEFINED = _pymcell.FILE_UNDEFINED
FILE_OVERWRITE = _pymcell.FILE_OVERWRITE
FILE_SUBSTITUTE = _pymcell.FILE_SUBSTITUTE
FILE_APPEND = _pymcell.FILE_APPEND
FILE_APPEND_HEADER = _pymcell.FILE_APPEND_HEADER
FILE_CREATE = _pymcell.FILE_CREATE
REPORT_CONTENTS = _pymcell.REPORT_CONTENTS
REPORT_WORLD = _pymcell.REPORT_WORLD
REPORT_ENCLOSED = _pymcell.REPORT_ENCLOSED
REPORT_TRIGGER = _pymcell.REPORT_TRIGGER
class output_set(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_set, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_set, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.output_set_next_set
    __swig_getmethods__["next"] = _pymcell.output_set_next_get
    if _newclass:next = _swig_property(_pymcell.output_set_next_get, _pymcell.output_set_next_set)
    __swig_setmethods__["block"] = _pymcell.output_set_block_set
    __swig_getmethods__["block"] = _pymcell.output_set_block_get
    if _newclass:block = _swig_property(_pymcell.output_set_block_get, _pymcell.output_set_block_set)
    __swig_setmethods__["outfile_name"] = _pymcell.output_set_outfile_name_set
    __swig_getmethods__["outfile_name"] = _pymcell.output_set_outfile_name_get
    if _newclass:outfile_name = _swig_property(_pymcell.output_set_outfile_name_get, _pymcell.output_set_outfile_name_set)
    __swig_setmethods__["file_flags"] = _pymcell.output_set_file_flags_set
    __swig_getmethods__["file_flags"] = _pymcell.output_set_file_flags_get
    if _newclass:file_flags = _swig_property(_pymcell.output_set_file_flags_get, _pymcell.output_set_file_flags_set)
    __swig_setmethods__["chunk_count"] = _pymcell.output_set_chunk_count_set
    __swig_getmethods__["chunk_count"] = _pymcell.output_set_chunk_count_get
    if _newclass:chunk_count = _swig_property(_pymcell.output_set_chunk_count_get, _pymcell.output_set_chunk_count_set)
    __swig_setmethods__["header_comment"] = _pymcell.output_set_header_comment_set
    __swig_getmethods__["header_comment"] = _pymcell.output_set_header_comment_get
    if _newclass:header_comment = _swig_property(_pymcell.output_set_header_comment_get, _pymcell.output_set_header_comment_set)
    __swig_setmethods__["exact_time_flag"] = _pymcell.output_set_exact_time_flag_set
    __swig_getmethods__["exact_time_flag"] = _pymcell.output_set_exact_time_flag_get
    if _newclass:exact_time_flag = _swig_property(_pymcell.output_set_exact_time_flag_get, _pymcell.output_set_exact_time_flag_set)
    __swig_setmethods__["column_head"] = _pymcell.output_set_column_head_set
    __swig_getmethods__["column_head"] = _pymcell.output_set_column_head_get
    if _newclass:column_head = _swig_property(_pymcell.output_set_column_head_get, _pymcell.output_set_column_head_set)
    def __init__(self, *args): 
        """__init__(self) -> output_set"""
        this = _pymcell.new_output_set(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_output_set
    __del__ = lambda self : None;
output_set_swigregister = _pymcell.output_set_swigregister
output_set_swigregister(output_set)

OUTPUT_BY_STEP = _pymcell.OUTPUT_BY_STEP
OUTPUT_BY_TIME_LIST = _pymcell.OUTPUT_BY_TIME_LIST
OUTPUT_BY_ITERATION_LIST = _pymcell.OUTPUT_BY_ITERATION_LIST
class sym_table_head(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_table_head, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_table_head, name)
    __repr__ = _swig_repr
    __swig_setmethods__["entries"] = _pymcell.sym_table_head_entries_set
    __swig_getmethods__["entries"] = _pymcell.sym_table_head_entries_get
    if _newclass:entries = _swig_property(_pymcell.sym_table_head_entries_get, _pymcell.sym_table_head_entries_set)
    __swig_setmethods__["n_entries"] = _pymcell.sym_table_head_n_entries_set
    __swig_getmethods__["n_entries"] = _pymcell.sym_table_head_n_entries_get
    if _newclass:n_entries = _swig_property(_pymcell.sym_table_head_n_entries_get, _pymcell.sym_table_head_n_entries_set)
    __swig_setmethods__["n_bins"] = _pymcell.sym_table_head_n_bins_set
    __swig_getmethods__["n_bins"] = _pymcell.sym_table_head_n_bins_get
    if _newclass:n_bins = _swig_property(_pymcell.sym_table_head_n_bins_get, _pymcell.sym_table_head_n_bins_set)
    def __init__(self, *args): 
        """__init__(self) -> sym_table_head"""
        this = _pymcell.new_sym_table_head(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_sym_table_head
    __del__ = lambda self : None;
sym_table_head_swigregister = _pymcell.sym_table_head_swigregister
sym_table_head_swigregister(sym_table_head)

class sym_entry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_entry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_entry, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.sym_entry_next_set
    __swig_getmethods__["next"] = _pymcell.sym_entry_next_get
    if _newclass:next = _swig_property(_pymcell.sym_entry_next_get, _pymcell.sym_entry_next_set)
    __swig_setmethods__["sym_type"] = _pymcell.sym_entry_sym_type_set
    __swig_getmethods__["sym_type"] = _pymcell.sym_entry_sym_type_get
    if _newclass:sym_type = _swig_property(_pymcell.sym_entry_sym_type_get, _pymcell.sym_entry_sym_type_set)
    __swig_setmethods__["name"] = _pymcell.sym_entry_name_set
    __swig_getmethods__["name"] = _pymcell.sym_entry_name_get
    if _newclass:name = _swig_property(_pymcell.sym_entry_name_get, _pymcell.sym_entry_name_set)
    __swig_setmethods__["value"] = _pymcell.sym_entry_value_set
    __swig_getmethods__["value"] = _pymcell.sym_entry_value_get
    if _newclass:value = _swig_property(_pymcell.sym_entry_value_get, _pymcell.sym_entry_value_set)
    def __init__(self, *args): 
        """__init__(self) -> sym_entry"""
        this = _pymcell.new_sym_entry(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_sym_entry
    __del__ = lambda self : None;
sym_entry_swigregister = _pymcell.sym_entry_swigregister
sym_entry_swigregister(sym_entry)

class sym_table_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_table_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_table_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.sym_table_list_next_set
    __swig_getmethods__["next"] = _pymcell.sym_table_list_next_get
    if _newclass:next = _swig_property(_pymcell.sym_table_list_next_get, _pymcell.sym_table_list_next_set)
    __swig_setmethods__["node"] = _pymcell.sym_table_list_node_set
    __swig_getmethods__["node"] = _pymcell.sym_table_list_node_get
    if _newclass:node = _swig_property(_pymcell.sym_table_list_node_get, _pymcell.sym_table_list_node_set)
    def __init__(self, *args): 
        """__init__(self) -> sym_table_list"""
        this = _pymcell.new_sym_table_list(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_sym_table_list
    __del__ = lambda self : None;
sym_table_list_swigregister = _pymcell.sym_table_list_swigregister
sym_table_list_swigregister(sym_table_list)

class vector2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector2, name)
    __repr__ = _swig_repr
    __swig_setmethods__["u"] = _pymcell.vector2_u_set
    __swig_getmethods__["u"] = _pymcell.vector2_u_get
    if _newclass:u = _swig_property(_pymcell.vector2_u_get, _pymcell.vector2_u_set)
    __swig_setmethods__["v"] = _pymcell.vector2_v_set
    __swig_getmethods__["v"] = _pymcell.vector2_v_get
    if _newclass:v = _swig_property(_pymcell.vector2_v_get, _pymcell.vector2_v_set)
    def __init__(self, *args): 
        """__init__(self) -> vector2"""
        this = _pymcell.new_vector2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_vector2
    __del__ = lambda self : None;
vector2_swigregister = _pymcell.vector2_swigregister
vector2_swigregister(vector2)

class vector3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector3, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _pymcell.vector3_x_set
    __swig_getmethods__["x"] = _pymcell.vector3_x_get
    if _newclass:x = _swig_property(_pymcell.vector3_x_get, _pymcell.vector3_x_set)
    __swig_setmethods__["y"] = _pymcell.vector3_y_set
    __swig_getmethods__["y"] = _pymcell.vector3_y_get
    if _newclass:y = _swig_property(_pymcell.vector3_y_get, _pymcell.vector3_y_set)
    __swig_setmethods__["z"] = _pymcell.vector3_z_set
    __swig_getmethods__["z"] = _pymcell.vector3_z_get
    if _newclass:z = _swig_property(_pymcell.vector3_z_get, _pymcell.vector3_z_set)
    def __init__(self, *args): 
        """__init__(self) -> vector3"""
        this = _pymcell.new_vector3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pymcell.delete_vector3
    __del__ = lambda self : None;
vector3_swigregister = _pymcell.vector3_swigregister
vector3_swigregister(vector3)


def mult_matrix(*args) -> "void" :
  return _pymcell.mult_matrix(*args)
mult_matrix = _pymcell.mult_matrix

def normalize(*args) -> "void" :
  return _pymcell.normalize(*args)
normalize = _pymcell.normalize

def init_matrix(*args) -> "void" :
  return _pymcell.init_matrix(*args)
init_matrix = _pymcell.init_matrix

def scale_matrix(*args) -> "void" :
  return _pymcell.scale_matrix(*args)
scale_matrix = _pymcell.scale_matrix

def translate_matrix(*args) -> "void" :
  return _pymcell.translate_matrix(*args)
translate_matrix = _pymcell.translate_matrix

def rotate_matrix(*args) -> "void" :
  return _pymcell.rotate_matrix(*args)
rotate_matrix = _pymcell.rotate_matrix

def tform_matrix(*args) -> "void" :
  return _pymcell.tform_matrix(*args)
tform_matrix = _pymcell.tform_matrix

def vectorize(*args) -> "void" :
  return _pymcell.vectorize(*args)
vectorize = _pymcell.vectorize

def vect_length(*args) -> "double" :
  return _pymcell.vect_length(*args)
vect_length = _pymcell.vect_length

def dot_prod(*args) -> "double" :
  return _pymcell.dot_prod(*args)
dot_prod = _pymcell.dot_prod

def cross_prod(*args) -> "void" :
  return _pymcell.cross_prod(*args)
cross_prod = _pymcell.cross_prod

def vect_sum(*args) -> "void" :
  return _pymcell.vect_sum(*args)
vect_sum = _pymcell.vect_sum

def scalar_prod(*args) -> "void" :
  return _pymcell.scalar_prod(*args)
scalar_prod = _pymcell.scalar_prod

def distinguishable_vec3(*args) -> "int" :
  return _pymcell.distinguishable_vec3(*args)
distinguishable_vec3 = _pymcell.distinguishable_vec3

def distinguishable_vec2(*args) -> "int" :
  return _pymcell.distinguishable_vec2(*args)
distinguishable_vec2 = _pymcell.distinguishable_vec2

def distance_vec3(*args) -> "double" :
  return _pymcell.distance_vec3(*args)
distance_vec3 = _pymcell.distance_vec3

def parallel_segments(*args) -> "int" :
  return _pymcell.parallel_segments(*args)
parallel_segments = _pymcell.parallel_segments

def point_in_triangle(*args) -> "int" :
  return _pymcell.point_in_triangle(*args)
point_in_triangle = _pymcell.point_in_triangle

def same_side(*args) -> "int" :
  return _pymcell.same_side(*args)
same_side = _pymcell.same_side

def intersect_point_segment(*args) -> "int" :
  return _pymcell.intersect_point_segment(*args)
intersect_point_segment = _pymcell.intersect_point_segment

def cross2D(*args) -> "double" :
  return _pymcell.cross2D(*args)
cross2D = _pymcell.cross2D

def vectorize2D(*args) -> "void" :
  return _pymcell.vectorize2D(*args)
vectorize2D = _pymcell.vectorize2D

def point_in_triangle_2D(*args) -> "int" :
  return _pymcell.point_in_triangle_2D(*args)
point_in_triangle_2D = _pymcell.point_in_triangle_2D

def point_in_box(*args) -> "int" :
  return _pymcell.point_in_box(*args)
point_in_box = _pymcell.point_in_box
"""pyMCell helper functions.

This defines functions to help pyMCell interface with the user. It
combines calls of the low level swig wrapped c code so that the
resulting python function calls for users using pyMCell are more
intuitive.

"""

import pymcell as m


class Vector3(object):
    def __init__(self, x=0.0, y=0.0, z=0.0):
        self.x = x
        self.y = y
        self.z = z


def create_count(world, where, mol_sym, file_path, step):
    """Creates a count for a specified molecule in a specified region
    and initializes an output block for the count data that will be
    generated.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        where (sym_entry) -- symbol entry for the location you want to
            record
        mol_sym (sym_entry) -- symbol entry for the molecule
        file_path (dir) -- name of the file path to output the data to
        step -- frequency of output in seconds

    Returns:
        The return values count list, output set, output times and
        output structure

    """
    report_flags = m.REPORT_CONTENTS
    c_list = m.output_column_list()
    # XXX: m.ORIENT_NOT_SET is using -100 instead of SHRT_MIN (used typemap
    # for mcell_create_count in mcell_react_out.i) because limits.h does not
    # work well with swig
    count_list = m.mcell_create_count(
        world, mol_sym, m.ORIENT_NOT_SET, where, report_flags, None, c_list)

    os = m.output_set()
    os = m.mcell_create_new_output_set(
        None, 0, count_list.column_head, m.FILE_SUBSTITUTE, file_path)

    out_times = m.output_times_inlist()
    out_times.type = m.OUTPUT_BY_STEP
    out_times.step = step

    output = m.output_set_list()
    output.set_head = os
    output.set_tail = os

    m.mcell_add_reaction_output_block(world, output, 10000, out_times)

    return (count_list, os, out_times, output)


def create_species(world, name, D, is_2d):
    """Creates a molecule species

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- Name of the molecule species that will be
            generated
        D (double) -- Diffusion Coefficient for the molecule species
            that will be generated.
        is_2d (bool) -- Boolean describing whether new species is a
            surface molecule

    Returns:
        (mcell_symbol) Returns a species sym_entry

    """
    species_def = m.mcell_species_spec()
    species_def.name = name
    species_def.D = D
    is_2d = 1 if is_2d else 0
    species_def.is_2d = is_2d
    species_def.custom_time_step = 0
    species_def.target_only = 0
    species_def.max_step_length = 0

    species_temp_sym = m.mcell_symbol()
    species_sym = m.mcell_create_species(
        world, species_def, species_temp_sym)

    return species_sym


def create_reaction(
        world, reactants, products, rate_constant,
        backward_rate_constant=0.0, surf_class=None, name=None):
    """Creates a molecular reaction

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        reactants (mcell_species_list) -- list of species that are the
            reactants for the reaction
        products (mcell_species_list) -- list of species that are the
            products for the reaction
        rate_constant (double) -- the rate constant for the forward
            direction reaction -> product
        backward_rate_constant (double)(optional) -- the rate constant
            for the backward direction reaction <- product
        surf_class (mcell species list surface class)(optional) -- the
            surface class upon which the reaction will happen
        name (string)(optional) -- Name of the reaction

    Returns:
        void -- creates a reaction, by generating reaction_rates
            structure

    """

    if surf_class:
        # Do nothing, surf_class has been added and a null object is not needed
        pass
    else:
        surf_class = m.mcell_add_to_species_list(None, False, 0, None)

    arrow = m.reaction_arrow()
    # reversible reaction e.g. A<->B
    if backward_rate_constant:
        arrow.flags = m.ARROW_BIDIRECTIONAL
        rate_constant = m.mcell_create_reaction_rates(
            m.RATE_CONSTANT, rate_constant, m.RATE_CONSTANT,
            backward_rate_constant)
    # irreversible reaction e.g. A->B
    else:
        arrow.flags = m.REGULAR_ARROW
        rate_constant = m.mcell_create_reaction_rates(
            m.RATE_CONSTANT, rate_constant, m.RATE_UNSET, 0)
    arrow.catalyst = m.mcell_species()
    arrow.catalyst.next = None
    arrow.catalyst.mol_type = None
    arrow.catalyst.orient_set = 0
    arrow.catalyst.orient = 0

    if (name):
        name_sym = m.mcell_new_rxn_pathname(world, name)
    else:
        name_sym = None
    m.mcell_add_reaction_simplified(
        world, reactants, arrow, surf_class, products, rate_constant, name_sym)


def create_instance_object(world, name):
    """Creates an instance object. Simple translation from wrapped code
    to python function. Frees the user from having to initialize the
    scene object and then pass it in and generate the object.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- name of the instance object

    Returns:
        instance object

    """
    scene_temp = m.object()
    return m.mcell_create_instance_object(world, name, scene_temp)


def create_surf_class(world, name):
    """Creates a surface class. Simple translation from wrapped code to
    python function Frees the user from having to initialize the surface
    class symbol and then pass it in and generate the object.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- name of the instance object

    Returns:
        mcell_symbol for surface class

    """

    sc_temp = m.mcell_symbol()
    return m.mcell_create_surf_class(world, name, sc_temp)


def create_release_site(
        world, scene, pos, diam, shape, number, mol_sym, name):
    """Creates a molecule release site

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        scene (instance object) -- scene for mcell simulation
        pos (vector3) -- position of release site
        diam (vector3) -- diameter of release site
        number (int) -- number to be release at release site
        mol_sym (mcell_symbol) -- species to be released
        name (string) -- name of the release site

    Returns:
        void -- generates a species release site

    """

    position = m.vector3()
    position.x = pos.x
    position.y = pos.y
    position.z = pos.z
    diameter = m.vector3()
    diameter.x = diam.x
    diameter.y = diam.y
    diameter.z = diam.z

    mol_list = m.mcell_add_to_species_list(mol_sym, False, 0, None)
    rel_object = m.object()
    release_object = m.mcell_create_geometrical_release_site(
        world, scene, name, shape, position, diameter, mol_list, number, 1,
        None, rel_object)
    m.mcell_delete_species_list(mol_list)

    return (position, diameter, release_object)


def create_region_release_site(
        world, scene, mesh, release_name, reg_name, number, mol_sym):
    """Creates a release site on a specific region

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        scene (instance object) -- scene for mcell simulation
        mesh (mesh object) -- scene object where the release will occur
        release_name (string) -- name of the region release site
        reg_name (string) -- name of the region for the release site
        number (int) -- number to be released at the region release site
        mol_sym (mcell_symbol) -- species to be released

    Returns:
        release object (object)

    """

    mol_list = m.mcell_add_to_species_list(mol_sym, False, 0, None)
    rel_object = m.object()
    release_object = m.mcell_create_region_release(
        world, scene, mesh, release_name, reg_name, mol_list, number, 1, None,
        rel_object)
    m.mcell_delete_species_list(mol_list)

    return release_object


def create_box(world, scene, half_length, name):
    """Creates the verteces and lines of a cube object at the origin

    Args:
        half_length (double) -- half length of the cube

    Returns:
        vertex list and element connection list

    """

    hl = half_length
    verts = m.mcell_add_to_vertex_list(hl, hl, -hl, None)
    verts = m.mcell_add_to_vertex_list(hl, -hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, -hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(hl, hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(hl, -hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, -hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, hl, hl, verts)

    elems = m.mcell_add_to_connection_list(1, 2, 3, None)
    elems = m.mcell_add_to_connection_list(7, 6, 5, elems)
    elems = m.mcell_add_to_connection_list(0, 4, 5, elems)
    elems = m.mcell_add_to_connection_list(1, 5, 6, elems)
    elems = m.mcell_add_to_connection_list(6, 7, 3, elems)
    elems = m.mcell_add_to_connection_list(0, 3, 7, elems)
    elems = m.mcell_add_to_connection_list(0, 1, 3, elems)
    elems = m.mcell_add_to_connection_list(4, 7, 5, elems)
    elems = m.mcell_add_to_connection_list(1, 0, 5, elems)
    elems = m.mcell_add_to_connection_list(2, 1, 6, elems)
    elems = m.mcell_add_to_connection_list(2, 6, 3, elems)
    elems = m.mcell_add_to_connection_list(4, 0, 7, elems)

    pobj = m.poly_object()
    pobj.obj_name = name
    pobj.vertices = verts
    pobj.num_vert = 8
    pobj.connections = elems
    pobj.num_conn = 12

    mesh_temp = m.object()
    mesh = m.mcell_create_poly_object(world, scene, pobj, mesh_temp)

    return mesh


def create_polygon_object(world, vert_list, face_list, scene, name):
    """Creates a polygon object from a vertex and element lest

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        vert_list (vertex list) -- verteces for the polygon
        face_list (element connection list) -- faces for the polygon
        scene (instance object) -- scene for mcell simulation
        name (string) -- name of polygon object that will be created

    Returns:
        polygon object
    """

    verts = None
    for x, y, z in vert_list:
        verts = m.mcell_add_to_vertex_list(x, y, z, verts)

    elems = None
    for x, y, z in face_list:
        elems = m.mcell_add_to_connection_list(x, y, z, elems)

    pobj = m.poly_object()
    pobj.obj_name = name
    pobj.vertices = verts
    pobj.num_vert = len(vert_list)
    pobj.connections = elems
    pobj.num_conn = len(face_list)

    mesh_temp = m.object()
    mesh = m.mcell_create_poly_object(world, scene, pobj, mesh_temp)

    return mesh


def create_surface_region(world, mesh, surf_reg_face_list, region_name):
    """Creates a surface region

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        mesh (polygon object) -- object where surface region will reside
        surf_reg_face_list (element connection list) -- list of surface
            region faces
        region_name (string) -- name of the surface region being created

    Returns:
        region object

    """

    surface_region = m.mcell_create_region(world, mesh, region_name)

    surf_reg_faces = None
    for idx in surf_reg_face_list:
        surf_reg_faces = m.mcell_add_to_region_list(surf_reg_faces, idx)

    m.mcell_set_region_elements(surface_region, surf_reg_faces, 1)

    return surface_region

# This file is compatible with both classic and new-style classes.


